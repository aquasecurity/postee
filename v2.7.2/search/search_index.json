{"config":{"indexing":"full","jieba_dict":null,"jieba_dict_user":null,"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"<p></p>  <p>Postee is a simple message routing application that receives input messages through a webhook interface, and can take enforce actions using predefined outputs via integrations.</p> <p>Primary use of Postee is to act as a message relay and notification service that integrates with a variety of third-party services. Postee can also be used for sending vulnerability scan results or audit alerts from Aqua Platform to collaboration systems.</p> <p>In addition, Postee can also be used to enforce pre-defined behaviours that can orchestrate actions based on input messages as triggers.</p> <p></p>","title":"Introduction"},{"location":"actions/","text":"","title":"Actions"},{"location":"actions/#motivation","text":"<p>Proper alert management can help security practitioners make informed decisions about their codebase. However, security alerts can cause fatigue if acting on them isn\u2019t possible. Postee, an open source security alert management tool, helps mitigate some of those concerns. It enables teams to define routes and rules by which alerts are handled and redirected to</p>","title":"Motivation"},{"location":"actions/#user-stories","text":"<p>In a typical Postee setup, users can configure the tool to receive events from a variety of sources over a webhook. This allows for ease of use in existing environments. Furthermore, users can configure Postee to process these incoming events and, based on logic defined via Rego rules, send them to different actions.</p> <p>As a Postee User</p> <ul> <li> <p>I want, to be able to remove a vulnerable image from my cluster upon a Trivy scan So that, I can keep such images unavailable for deployment.</p> </li> <li> <p>I want, to ship Tracee security notification logs from my node when events are detected  So that, I can build a timelog for forensics purposes.</p> </li> <li> <p>I want, to be able to add labels to my deployments when Starboard detects a vulnerable image in my cluster  So that, I can effectively tag my resources.</p> </li> </ul> <p></p> <p>Actions are remote services that messages should be sent to. Each action has two mandatory fields, which are 'name' and 'type'.</p>    Key Description Possible Values Example     name Unique name of the action. This name is used in the route definition. Any string teams-action   type The type of the action You can choose from the following types: email, jira, slack, teams, webhook, splunk, serviceNow email     <p>Tip</p> <p>Depending on the 'type', additional parameters are required.</p>","title":"User Stories"},{"location":"actions/#jira","text":"<p>Follow these steps to set up JIRA integration:</p> <ol> <li>Get a new token for user:<ul> <li>Login to Jira Cloud.   Go to the user profile API tokens (JIRA Cloud users can find it here).</li> <li>Click on the Create API Token. A new API token for the user is created.</li> <li>Login to Jira Server/Data center   Select your profile picture at top right of the screen, then choose  Settings &gt; Personal Access Tokens. Select Create token. Give your new token a name. Optionally, for security reasons, you can set your token to automatically expire after a set number of days. Click Create. A new PAT for the user is created.</li> </ul> </li> <li>Fill jira action in cfg.yaml:<ul> <li>Jira Cloud:<ul> <li>User: your email.</li> <li>Password: your API token.</li> </ul> </li> <li>Jira Server/Data center:<ul> <li>User: your UserName.</li> <li>Password: your Password.\\   or</li> <li>Token: your Personal Access Tokens.</li> </ul> </li> </ul> </li> </ol>    Key Description Possible Values     url Jira project url    project-key The JIRA project key    user Jira user. Use email for Jira Cloud and UserName for Jira Server/Data Center    password Optional: User's password. API token can also be used for Cloud Jira instances.    token Optional: User's Personal Access Token. Used only for Jira Server/Data Center    board Optional: JIRA board key    priority Optional: ticket priority, e.g., High    assignee Optional: comma separated list of users (emails) that will be assigned to ticket, e.g., [\"john@yahoo.com\"]. To assign a ticket to the Application Owner email address (as defined in Aqua Application Scope, owner email field), specify [\"&lt;%application_scope_owner%&gt;\"] as the assignee value    issuetype Optional: issue type, e.g., Bug    labels Optional: comma separated list of labels that will be assigned to ticket, e.g., [\"label1\", \"label2\"]    sprint Optional: Sprint name, e.g., \"3.5 Sprint 8\"     <p>For Jira you can also specify custom fields that will be populated with values. Use the <code>unknowns</code> parameter in cfg.yaml for custom fields. Under the <code>unknowns</code> parameter, specify the list of fields names to provide value for. Field name can contains spaces.</p> <p>Possible options for getting the field name:</p>  Get field name from Jira UI <ol> <li>Move to your jira.</li> <li>Navigate to Settings() &gt; Issues &gt; Custom fields under the Fields section: </li> <li>Click on the required field. </li> <li>Get value from Name field.</li> </ol>   Get field name from Jira REST API <ol> <li>Get all Jira fields according to instructions</li> <li>Find needed field:</li> </ol> <p><pre><code> ...\n     \"id\": \"customfield_10014\",\n     \"key\": \"customfield_10014\",\n     \"name\": \"Epic Link\",\n     \"untranslatedName\": \"Epic Link\",\n     \"custom\": true,\n     \"orderable\": true,\n     \"navigable\": true,\n     \"searchable\": true,\n     \"clauseNames\": [\n       \"cf[10014]\",\n       \"Epic Link\"\n     ],\n     \"schema\": {\n       \"type\": \"any\",\n       \"custom\": \"com.pyxis.greenhopper.jira:gh-epic-link\",\n       \"customId\": 10014\n     }\n   },\n ...\n</code></pre> 3. Get value from Name field.</p> <p>Example of using the <code>unknowns</code> parameter in the cfg.yaml file:</p> <pre><code>unknowns:\n     Epic Link: \"K8S-1\"\n</code></pre>   <p>Tip</p> <p>You can add \"-numeric-field\", \"-multiple-value\", \"multiple-line-text-field\", \"-date-time-picker\" and \"-field-url\" as suffix to the custom field name, to specify what is the field type.</p> <p>For example:   <pre><code>unknowns:\n     mycustom: \"this is a text custom field\"\n     mycustom-numeric-field: 123\n     mycustom-multiple-value: 1,2,3\n     mycustom-multiple-line-text-field: \"text \\n moretext\"\n     mycustom-date-time-picker: 2014-04-11T12:14:26.880+0400\n     mycustom-url: https://tour.golang.org/moretypes/7\n</code></pre></p>","title":"Jira"},{"location":"actions/#email","text":"Key Description Possible Values     use-mx Whether to send the email as an SMTP server or a client. Specify 'true' if you would like to send email as an smtp server, in this case you don't need to provide user, password, host and port. true, false   user Optional, if auth supported. User name (usually email address)    password Optional, if auth supported. Password    host SMTP host name    port SMTP port    sender Sender's email address    recipients Recipients (array of comma separated emails), e.g. [\"john@yahoo.com\"]. To send the email to the Application Owner email address (as defined in Aqua Application Scope, owner email field), specify [\"&lt;%application_scope_owner%&gt;\"] as the recipients value","title":"Email"},{"location":"actions/#slack","text":"<p>Getting the Slack webhooks Create a Slack Custom App.</p> <p>Copy webhook url to the Postee config</p>    Key Description Possible Values     url Slack WebHook URL (includes the access key)","title":"Slack"},{"location":"actions/#ms-teams","text":"<p>Open your Microsoft Teams client. Click on the \"...\" near the channel you would like to send notifications to.</p> <p>Choose \"Connectors\". The connectors window will open. Look for the \"Incoming Webhook\" connector (it is under the \"All\" category).</p> <p>Click \"Add\" near the Incoming Webhook connector. Click \"Add\" again. Provide a name and click \"Create\".</p> <p>You will be provided with a URL address. Copy this URL and put it in the cfg.yaml.</p>    Key Description Possible Values     url MS Teams WebHook URL","title":"MS Teams"},{"location":"actions/#splunk","text":"<p>You will need to care about an HTTP Event Collector in Splunk Enterprise or Splunk Cloud.</p>  <p>Tip</p> <p>This can usually be found in the Splunk console under \"Settings -&gt; Data Inputs -&gt; HTTP Event Collector -&gt; Add New\".</p>  <p>Once you create an HTTP Event Collector you will receive a token. You should provide this token, together with the Splunk HTTP Collector URL, as part of the cfg.yaml settings.</p>    Key Description Possible Values     token The Splunk HTTP event collector token    url URL to Splunk HTTP event collector (e.g. http://server:8088)    size-limit Optional. Maximum scan length, in bytes. Default: 10000 10000","title":"Splunk"},{"location":"actions/#servicenow","text":"Key Description Possible Values     user ServiceNow user name    password User API key / password    instance Name of ServiceNow Instance (usually the XXX at XXX.servicenow.com)    board ServiceNow board name to open tickets on. Default is \"incident\"","title":"ServiceNow"},{"location":"actions/#nexus-iq","text":"Key Description Possible Values     user Nexus IQ user name    password Nexus IQ password    url Url of Nexus IQ server    organization-id Organization UID like \"222de33e8005408a844c12eab952c9b0\"","title":"Nexus IQ"},{"location":"actions/#opsgenie","text":"Set up OpsGenie and get a token <ol> <li>Go to your Opsgenie and select Teams from menu.</li> <li>Select your team to access your team dashboard.</li> <li>Select Integrations from left navigation.</li> <li>Select Add Integration.</li> <li>Select API Integration.</li> <li>Copy <code>API Key</code>.</li> <li>When done with all configurations, select Save Integration to enable the integration.</li> </ol> <p>See more details here: Set up an integrated tool for Opsgenie.</p>   <p>Caution</p> <p>Postee requires an API key from an API integration. This can be added under the Settings -&gt; Integrations tab. Or it can under a team's Integrations tab.</p> <p>If the integration assigns an alert to a team, it can only create alerts for that team.</p> <p>An API key from the <code>API Key Management</code> tab will produce an HTTP 403 error. This API Key is valid but cannot create alerts as it lacks necessary permissions. </p>     Key Required Description Possible Values     token true an API key from an API integration    user false Display name of the request owner.    assignee false Comma separated list of users that the alert will be routed to send notifications    recipients false Comma separated list of users that the alert will become visible to without sending any notification    priority false Specify the alert priority. Default is \"P3\" \"P1\" \"P2\" \"P3\" \"P4\" \"P5\"   tags false Comma separated list of the alert tags.    alias false Client-defined identifier of the alert.    entity false Entity field of the alert that is generally used to specify which domain alert is related to.","title":"OpsGenie"},{"location":"actions/#exec","text":"Option Usage     env Optional, custom environment variables to be exposed in the shell of the executing script   input-file Required, custom shell script to executed   exec-script Required, inline shell script executed    <p>The Exec Action also internally exposes the <code>$POSTEE_EVENT</code> environment variable with the input event that triggered the action. This can be helpful in situations where the event itself contains useful information.</p> <p>Below is an example of using <code>$POSTEE_EVENT</code>. It uses the inline exec-script script:</p> <p></p>","title":"Exec"},{"location":"actions/#http","text":"<p></p>    Option Usage     URL Required, URL of the remote server   Method Required, e.g., GET, POST   Headers Optional, custom headers to send   Timeout Optional, custom timeout for HTTP call   Bodyfile Optional, input file for HTTP post body","title":"HTTP"},{"location":"actions/#kubernetes","text":"<p></p>    Option Usage     kube-namespace Required. Kubernetes namespace to use.   kube-config-file Required. Path to .kubeconfig file   kube-label-selector Required, if specifying labels or annotations.   kube-actions Optional, key-value pair of labels and annotationsLabels must be added via \"labels\" key and Annotations via \"annotations\".","title":"Kubernetes"},{"location":"actions/#docker","text":"<p></p>    Option Usage     docker-image-name Required. Image name of the docker image.   docker-cmd Required. Command to run inside the docker image.   docker-env Optional. Environment variables to set in the container.   docker-network Optional. Connect the action container to the specified network.   docker-volume-mounts Optional*. Volume mounts present inside the container. * If you have specified volume mounts, you also need to pass them through into the postee docker container     <p>Note</p> <p>When running Postee in a Docker container, it is required to mount the Docker socket within the Postee container to be able to spin up Docker Action container instances. This can be done as follows:   <pre><code>docker run --rm --name=postee --group-add $(stat -c '%g' /var/run/docker.sock) -v /var/run/docker.sock:/var/run/docker.sock -v /path/to/cfg.yaml:/config/cfg.yaml  -e POSTEE_CFG=/config/cfg.yaml -e POSTEE_HTTP=0.0.0.0:8084     -e POSTEE_HTTPS=0.0.0.0:8444     -p 8084:8084 -p 8444:8444 aquasecurity/postee:latest\n</code></pre></p>   <p>Tip</p> <p>If you have specified volume mounts for a docker container and use Postee in a docker container as well, remember to mount them within the Postee container as well:   <pre><code>docker run --rm --name=postee --group-add $(stat -c '%g' /var/run/docker.sock) -v /var/run/docker.sock:/var/run/docker.sock -v /path/to/cfg.yaml:/config/cfg.yaml  -v /my/custom/volume:/my/custom/volume -e POSTEE_CFG=/config/cfg.yaml -e POSTEE_HTTP=0.0.0.0:8084     -e POSTEE_HTTPS=0.0.0.0:8444     -p 8084:8084 -p 8444:8444 aquasecurity/postee:latest\n</code></pre></p>","title":"Docker"},{"location":"actions/#generic-webhook","text":"Key Description Possible Values     url Webhook URL    timeout Webhook timeout      <p>Tip</p>  <p>The generic webhook action can be used for sending Postee output to any endpoint that can receive a request. You can find some interesting examples as part of the Postee Blueprints</p>","title":"Generic Webhook"},{"location":"advanced/","text":"<p>This page covers some advanced topics that the experienced users of Postee might like to try. </p>","title":"Advanced"},{"location":"advanced/#using-environment-variables-in-postee-configuration-file","text":"<p>Postee supports use of environment variables for Output fields: User, Password and Token. </p> <p>Add prefix <code>$</code> to the environment variable name in the configuration file, for example: <pre><code>actions:\n- name: my-jira   \n  type: jira     \n  enable: true\n  user: $JIRA_USERNAME\n  token: $JIRA_SERVER_TOKEN         \n</code></pre></p>","title":"Using environment variables in Postee Configuration File"},{"location":"advanced/#customizing-templates","text":"<p>Postee loads bundle of templates from <code>rego-templates</code> folder. This folder includes several templates shipped with Postee, which can be used out of the box. You can add additional custom templates by placing Rego file under the 'rego-templates' directory.</p> <p>To create your own template, you should create a new file under the 'rego-templates' directory, and use the Rego language for the actual template code.</p> <p>Message payload is referenced as <code>input</code> when template is rendered. The result variable should be used to store the output message, which is the result of the template formatting.</p> <p>The following variables should be defined in the custom Rego template.</p>    Key Description Type     result message body Can be either string or json   title message title string   aggregation_pkg reference to package used to aggregate messages (when aggregate-message-timeout or aggregate-message-number options are used). If it's missed then aggregation feature is not supported valid rego package    <p>So the simplest example of Rego template would look like: <pre><code>package example.vuls.html\n\ntitle:=\"Vulnerabilities are found\"\nresult:=sprintf(\"Vulnerabilities are found while scanning of image: &lt;i&gt;%s&lt;/i&gt;\", [input.image])\n</code></pre></p> <p>Two examples are shipped with the app. One produces output for slack integration and another one builds html output which can be used across several integrations. These example can be used as starting point for message customization</p>","title":"Customizing Templates"},{"location":"advanced/#data-persistence","text":"<p>The Postee container uses BoltDB to store information about previously scanned images. This is used to prevent resending messages that were already sent before. The size of the database can grow over time. Every image that is saved in the database uses 20K of storage.</p> <p>Postee supports \u2018PATH_TO_DB\u2019 environment variable to change the database directory. To use, set the \u2018PATH_TO_DB\u2019 environment variable to point to the database file, for example: PATH_TO_DB=\"./database/webhook.db\". </p> <p>By default, the directory for the database file is \u201c/server/database/webhook.db\u201d.</p>  <p>Tip<p>If you would like to persist the database file between restarts of the Postee container, then you should use a persistent storage option to mount the \"/server/database\" directory of the container.</p> </p>  <p>The \"deploy/kubernetes\" directory in this project contains an example deployment that includes a basic Host Persistency.</p>","title":"Data Persistence"},{"location":"aquacloud/","text":"","title":"Aqua Cloud"},{"location":"aquacloud/#configure-the-aqua-server-with-webhook-integration","text":"<p>Postee can be integrated with Aqua Console to deliver vulnerability and audit messages to target systems.</p> <p>You can configure the Aqua Server to send a Webhook notification whenever a new vulnerability is found. Navigate to the Image Scan Results Webhook page, under the \"Settings\" menu.</p> <p></p> <p>Click \"Enable sending image scan results to webhook\", and specify the URL of Postee. Now, scan an image and look at the Postee log files - you will see that Postee have received an incoming message once scan is done, and that the message was routed based on the cfg.yaml configuration.</p> <p>You can also configure the Aqua Server to send a Webhook notification for every audit message. Navigate to the Log Management page, under the \"Integrations\" menu.</p> <p></p> <p>Click on the \"Webhook\" item, and specify the URL of Postee.</p> <p>Now every audit event in Aqua will be sent to Postee. You can configure routes and input message conditions in Postee cfg.yaml to forward appropriate messages to target systems.</p> <p>The Postee URL is in the following formats:</p>  <p><code>https://&lt;Postee IP or DNS&gt;:8445</code> <code>http://&lt;Postee IP or DNS&gt;:8082</code></p>   <p>Tip<p>For more details about the Postee URL installed using kubernetes click here</p> </p>","title":"Configure the Aqua Server with Webhook Integration"},{"location":"aquacloud/#validate-the-integration","text":"<p>To validate that the integration is working, you can scan a new image for security vulnerabilities from the Aqua Server UI (Images &gt; Add Image &gt; Specify Image Name &gt; Add).</p> <p>When vulnerabilities are found in an image, you will see that a JIRA ticket is created/ Email is received/ Slack message is posted to the channel.</p>  <p>Tip<p>To troubleshoot the integration, you can look at both the Aqua Postee container logs and the Aqua Server logs. Use the \"docker logs \" command to view these logs.*","title":"Validate the Integration"},{"location":"config/","text":"<p>When Postee receives a message it will process it based on routing rules and send it to the appropriate target. How does it know how to do that? Well, this information is defined in Postee's configuration file, cfg.yaml, which contains the following definitions:</p> <ol> <li>General settings</li> <li>Routes</li> <li>Templates</li> <li>Actions</li> </ol> <p>These sections will be described in detail as we proceed through the documentation.</p>","title":"Config File"},{"location":"controller-runner/","text":"","title":"Controller Runner Mode"},{"location":"controller-runner/#introduction","text":"<p>Postee can also be run in Controller/Runner mode. The idea is to decouple enforcement from execution, if applicable.</p>","title":"Introduction"},{"location":"controller-runner/#scenario","text":"<p>In the following scenario, consider two services: A and B. In the case of Service A, a Trivy scan is run and results of the scan result are sent to Postee for executing Actions upon.</p> <p>In the case of Service B, a Tracee container is constantly monitoring for malicious activity that happens on the host. When a Tracee finding is observed, it is sent to a local Postee Runner. This Postee Runner has the ability to locally execute a pre-defined Postee Action.</p> <p></p>","title":"Scenario"},{"location":"controller-runner/#configuration","text":"","title":"Configuration"},{"location":"controller-runner/#run-postee-in-controller-mode","text":"<pre><code>postee --cfgfile=./cfg-controller-runner.yaml --controller-mode --controller-ca-root=\"./rootCA.pem\" --controller-tls-cert=\"./server-cert.pem\" --controller-tls-key=\"./server-key.pem\" --controller-seed-file=\"./seed.txt\"\n</code></pre>    Option Required Description     controller-mode true Enable Postee to run as a Controller   controller-ca-root false TLS CA Root Certificate for Controller   controller-tls-cert false TLS Certificate for Controller   controller-tls-key false TLS Key for Controller   controller-seed-file false Seed file for Controller     Example Controller/Runner Configuration <pre><code>name: Postee Controller Runner Demo\n\nroutes:\n- name: controller-only-route\n  input: contains(input.image, \"alpine\")\n  actions: [my-http-post-from-controller]\n  template: raw-json\n\n- name: runner-only-route\n  input: contains(input.SigMetadata.ID, \"TRC-1\")\n  serialize-actions: true\n  actions: [my-exec-from-runner, my-http-post-from-runner]\n  template: raw-json\n\n- name: controller-runner-route\n  input: contains(input.SigMetadata.ID, \"TRC-2\")\n  actions: [my-exec-from-runner, my-http-post-from-runner, my-http-post-from-controller]\n  template: raw-json\n\ntemplates:\n- name: raw-json\n  rego-package: postee.rawmessage.json\n\nactions:\n- name: stdout\n  type: stdout\n  enable: true\n\n- name: my-http-post-from-controller\n  type: http\n  enable: true\n  url: \"https://webhook.site/&lt;uuid&gt;\"\n  method: POST\n  headers:\n    \"Foo\": [ \"bar\" ]\n  timeout: 10s\n  body-content: |\n    This is an example of a inline body\n    Input Image: event.input.image\n\n- name: my-exec-from-runner\n  runs-on: \"postee-runner-1\"\n  type: exec\n  enable: true\n  env: [\"MY_ENV_VAR=foo_bar_baz\", \"MY_KEY=secret\"]\n  exec-script: |\n    #!/bin/sh\n    echo $POSTEE_EVENT\n    echo \"this is hello from postee\"\n\n- name: my-http-post-from-runner\n  runs-on: \"postee-runner-1\"\n  type: http\n  enable: true\n  url: \"https://webhook.site/&lt;uuid&gt;\"\n  method: POST\n  body-content: |\n    This is an another example of a inline body\n    Event ID: event.input.SigMetadata.ID\n</code></pre>  <p>The only notable change in the configuration as defined is of the Actions that can run on Runners. Observe the <code>runs-on</code> clause below. <pre><code>- name: my-exec-from-runner\n  runs-on: \"postee-runner-1\"\n  type: exec\n  enable: true\n  exec-script: |\n    #!/bin/sh\n    echo $POSTEE_EVENT\n    echo \"this is hello from postee\"\n</code></pre></p> <p>In this case this particular Action will run on Postee Runner that identifies itself as <code>postee-runner-1</code></p>","title":"Run Postee in Controller mode:"},{"location":"controller-runner/#run-postee-in-runner-mode","text":"<pre><code>postee --controller-url=\"nats://0.0.0.0:4222\" --runner-ca-cert=\"./rootCA.pem\" --runner-tls-cert=\"./runner-cert.pem\" --runner-tls-key=\"./runner-key.pem\" --runner-seed-file=\"./seed.txt\", --runner-name=\"postee-runner-1\"  --url=0.0.0.0:9082 --tls=0.0.0.0:9445\n</code></pre>    Option Required Description     controller-url true The URL to the Postee Controller   runner-name true The Name of the Runner, as defined in configuration YAML   runner-ca-root false TLS Root CA Certificate for Runner   runner-tls-cert false TLS Certificate for Runner   runner-tls-key false TLS Key for Runner   runner-seed-file false Seed file for Runner","title":"Run Postee in Runner mode:"},{"location":"controller-runner/#secured-controllerrunner-channel","text":"<p>The communication channel between Controller and Runner can be optionally secured with TLS and be Authentication (AuthN). </p> <p>TLS can be enabled by passing the TLS cert and key through the optional <code>--controller-tls-cert</code> and <code>--controller-tls-key</code> flags for Controller and <code>--runner-tls-cert</code> and <code>--runner-tls-key</code> flags for Runner.</p> <p>AuthN can be enabled by passing the NATS Seed File. Postee uses NKeys, a public-key signature system based on Ed25519. </p> <p>A seed file should be treated as a secret. It can be passed to the Controller via the <code>--controller-seed-file</code> and the Runner via <code>--runner-seed-file</code>.</p> <p>This can be helpful in situations where Postee Config contains secrets that are configured in an Action that runs on a Runner. </p>","title":"Secured Controller/Runner Channel"},{"location":"controller-runner/#walkthrough","text":"<p>In the case of Tracee reporting a malicious finding, the Action might only make sense to run locally within the same environment where Tracee reported from. For instance, in the case of a Postee Action to kill a process reported within the malicious finding, the process will only exist on the host where Tracee reported from. Therefore, the need for a localized Postee that can handle this arises.</p> <p>Postee Runners can automatically bootstrap themselves upon startup, given the address of the Postee Controller. They only receive the relevant config info from the Postee Controller for the Actions and Routes they are responsible for. This helps by limiting the spread of secrets in your configuration to only those Runners where they are needed. If your deployment uses Actions where secrets are required, we recommend you run these Actions at the Controller level.</p> <p>The only Actions that a Postee Runner should run are Actions that are context/environment specific. A few examples (but not limited to) are: Killing a local process, Shipping local logs on host to a remote endpoint, etc.</p>","title":"Walkthrough"},{"location":"controller-runner/#additional-info","text":"<p>Postee Runners and Controllers are no different from a normal instance of vanilla Postee. Therefore, no changes to the producers are required to use this functionality.</p> <p>All events received by Postee Runners are reported upstream to the Controller. This has two benefits:</p> <ol> <li>Executions and Events received by the Runners can be monitored at a central level (Controller).</li> <li>Mixing of Runner and Controller Actions within a single Route, for ease of usage.</li> </ol> <p>Mixing of Runner and Controller Actions can be explained with a following sample configuration: <pre><code>- name: controller-only-route\n  input: contains(input.image, \"alpine\")\n  actions: [my-slack-message-from-controller]\n  template: raw-json\n\n- name: runner-only-route\n  input: contains(input.SigMetadata.ID, \"TRC-1\")\n  serialize-actions: true\n  actions: [my-exec-from-runner, my-http-post-from-runner]\n  template: raw-json\n\n- name: controller-runner-route\n  input: contains(input.SigMetadata.ID, \"TRC-2\")\n  serialize-actions: true\n  actions: [my-exec-from-runner, my-http-post-from-runner, my-jira-ticket-from-controller]\n  template: raw-json\n</code></pre></p> <p>In this sample configuration, we have three routes. One that solely executes on the Controller, another that solely executes on the Runner and a Mixed route.</p> <p>In the case of the Mixed route, the first two Actions are run on the Runner. These Actions are run locally as they might require environment specific things to run, as discussed above. The third Action is run from a Controller because of security reasons to not distribute secrets to a Runner. </p>","title":"Additional Info"},{"location":"controller-runner/#a-quick-note-on-serialization","text":"<p>The option of <code>serialize-actions</code> works as expected and guarantees true serialization for execution of Actions in the case of Controller only and Runner only routes. But for the case of Mixed routes (as described above) where executions can run on both Controller and Runner, this serialization cannot be strongly guaranteed due to the difference of execution environments (Runner and Controller).</p>","title":"A quick note on Serialization"},{"location":"demo/","text":"<p>In this demo, we\u2019ll walk through a scenario in which a user wants to act on a security event received from Tracee, an open source runtime security tool. In this scenario, the user will set up the Postee Exec Action to save logs for forensic purposes and then use the Postee HTTP Action to ship the saved logs to a remote server.</p> <p>In this case, the incoming security event from Tracee is received by Postee and evaluated by the following route YAML definition:</p> <p></p> <p>As seen above, the route has a Rego rule that evaluates the input to contain a certain signature ID, TRC-2, which represents anti-debugging activity. In addition, if the input is matched, the output is triggered.</p>","title":"Demo"},{"location":"demo/#exec-action","text":"<p>In this case, we call the Exec Action first and then the HTTP Action. They are defined as the following:</p> <p>The Exec Action can take in the following parameters:</p>    Option Usage     env Optional, custom environment variables to be exposed in the shell of the executing script   input-file Required, custom shell script to executed   exec-script Required, inline shell script executed    <p>The Exec Action also internally exposes the <code>$POSTEE_EVENT</code> environment variable with the input event that triggered the action. This can be helpful in situations where the event itself contains useful information.</p> <p>Below is an example of using <code>$POSTEE_EVENT</code>. It uses the inline exec-script script:</p> <p></p> <p>As you can see, we capture the incoming Postee event and write this event to the Tracee event log for forensic purposes.</p>","title":"Exec Action"},{"location":"demo/#http-action","text":"<p>Finally, we can configure the Postee HTTP Post Action to ship the captured event logs via our HTTP Action to our remote server.</p> <p></p>    Option Usage     URL Required, URL of the remote server   Method Required, e.g., GET, POST   Headers Optional, custom headers to send   Timeout Optional, custom timeout for HTTP call   Bodyfile Optional, input file for HTTP post body    <p>To run Postee in the container, we can invoke the Postee Docker container:</p> <pre><code>docker run --rm --name=postee \\\n-v &lt;path-to-cfg&gt;:/config/cfg-actions.yaml  \\\n-e POSTEE_CFG=/config/cfg-actions.yaml \\\n-e POSTEE_HTTP=0.0.0.0:8084  \\\n-e POSTEE_HTTPS=0.0.0.0:8444  \\\n-p 8084:8084 -p 8444:8444 aquasecurity/postee:latest\n</code></pre>","title":"HTTP Action"},{"location":"examples/","text":"<p>Here are some Postee configuration samples to showcase a variety of use cases.</p>  Forward all \"Block\" audit events <pre><code>name: myserver\naqua-server: https://myserver.com\nmax-db-size: 1000MB\ndelete-old-data: 100\ndb-verify-interval: 1\n\nroutes:\n- name: team-drift\n  input: input.level = \"block\"\n  actions: [my-teams]\n  template: raw-html\n\nactions:\n- name: my-teams\n  type: teams\n  enable: true\n  url: https://outlook.office.com/webhook/&lt;replace&gt;\n\ntemplates:\n- name: raw-html\n  rego-package:  postee.rawmessage.html\n</code></pre>   Forward Critical vulnerabilities <pre><code># This example will forward events of images with critical vulnerabilities to MS Teams.\n# Note that duplicate events of same image will be ignored for 30 days.\n\nname: myserver\naqua-server: https://myserver.com\nmax-db-size: 1000MB\ndelete-old-data: 100\ndb-verify-interval: 1\n\nroutes:\n- name: team-critical-vul\n  input: input.vulnerability_summary.critical &gt; 0\n  actions: [my-teams]\n  template: raw-html\n  plugins:\n  unique-message-props: [\"digest\",\"image\",\"registry\", \"vulnerability_summary.high\", \"vulnerability_summary.medium\", \"vulnerability_summary_low\"]\n  unique-message-timeout: 30d\n\nactions:\n- name: my-teams\n  type: teams\n  enable: true\n  url: https://outlook.office.com/webhook/&lt;replace&gt;\n\ntemplates:\n- name: raw-html\n  rego-package:  postee.rawmessage.html\n</code></pre>   Forward Drift events <pre><code># This example will forward events of Drift Prevention to MS Teams.\n\nname: myserver\naqua-server: https://myserver.com\nmax-db-size: 1000MB       #  Max size of DB. &lt;numbers&gt;&lt;unit suffix&gt; pattern is used, such as \"300MB\" or \"1GB\". If empty or 0 then unlimited\ndelete-old-data: 100    # delete data older than N day(s).  If empty then we do not delete.\ndb-verify-interval: 1   # hours. an Interval between tests of DB. Default: 1 hour\n\nroutes:\n- name: team-drift\n  input: contains(input.control, \"Drift\")\n  actions: [my-teams]\n  template: raw-html\n\nactions:\n- name: my-teams\n  type: teams\n  enable: true\n  url: https://outlook.office.com/webhook/&lt;replace&gt;\n\ntemplates:\n- name: raw-html                        #  Raw message json\n  rego-package:  postee.rawmessage.html #  HTLM template REGO package\n</code></pre>   Add Kubernetes Labels and Annotations <pre><code>name: tenant\naqua-server:\nmax-db-size: 1000MB\ndb-verify-interval: 1\n\nroutes:\n- name: stdout\n  actions: [ stdout ]\n  template: raw-json\n\n- name: actions-route\n  input: contains(input.SigMetadata.ID, \"TRC-2\")\n  actions: [my-k8s]\n  template: raw-json\n\ntemplates:\n- name: raw-json\n  rego-package: postee.rawmessage.json\n\nactions:\n- name: stdout\n  type: stdout\n  enable: true\n\n- name: my-k8s\n  type: kubernetes\n  enable: true\n  kube-namespace: \"default\"\n  kube-config-file: \"/path/to/kubeconfig\"\n  kube-label-selector: \"app=nginx-app\"\n  kube-actions:\n  labels:\n  foo-label: \"bar-value\"\n  bar-label: event.input.SigMetadata.ID\n  annotations:\n  foo-annotation: \"bar-value\"\n  bar-annotation: event.input.SigMetadata.ID\n</code></pre>   Run ad-hoc docker image <pre><code>name: tenant\naqua-server:\nmax-db-size: 1000MB\ndb-verify-interval: 1\n\nroutes:\n- name: stdout\n  actions: [ stdout ]\n  template: raw-json\n\n- name: actions-route\n  input: contains(input.SigMetadata.ID, \"TRC-2\")\n  actions: [stop-vulnerable-pod]\n  template: raw-json\n\ntemplates:\n- name: raw-json\n  rego-package: postee.rawmessage.json\n\nactions:\n- name: stdout\n  type: stdout\n  enable: true\n\n- name: stop-vulnerable-pod\n  type: docker\n  enable: true\n  docker-image-name: \"bitnami/kubectl:latest\"                          \n  docker-cmd: [\"delete\", \"pod\", event.input.SigMetadata.hostname]\n  docker-network: \"host\"\n  docker-volume-mounts:\n  \"path/to/.kube/config\": \"/.kube/config\"\n</code></pre>   Collect and send logs <pre><code>name: tenant\naqua-server: localhost\nmax-db-size: 1000MB\ndb-verify-interval: 1\n\nroutes:\n- name: stdout\n  actions: [ stdout ]\n  template: raw-json\n\n- name: actions-route\n  input: contains(input.SigMetadata.ID, \"TRC-2\")\n  serialize-actions: true\n  actions: [my-exec, my-http-post-file, my-http-post-content]\n  template: raw-json\n\ntemplates:\n- name: raw-json\n  rego-package: postee.rawmessage.json\n\nactions:\n- name: stdout\n  type: stdout\n  enable: true\n\n- name: my-exec\n  type: exec\n  enable: true\n  env: [\"MY_ENV_VAR=foo_bar_baz\", \"MY_KEY=secret\"]\n  exec-script: |\n  #!/bin/sh\n  echo $POSTEE_EVENT &gt;&gt; /tmp/postee.event.logs\n\n- name: my-http-post-file\n  type: http\n  enable: true\n  url: \"https://my-fancy-url.com\"\n  method: POST\n  body-file: /tmp/postee.event.logs\n\n- name: my-http-post-content\n  type: http\n  enable: true\n  url: \"https://my-fancy-url.com\"\n  method: POST\n  headers:\n  \"Foo\": [ \"bar\" ]\n  \"Haz\": [ \"baz\" ]\n  timeout: 10s\n  body-content: |\n  This is an example of a inline body\n  Event ID: event.input.Signature.ID   \n</code></pre>","title":"Simple Examples"},{"location":"install/","text":"<p>To run Postee you will first need to configure the Postee Configuration File, which contains all the message routing logic. After the configuration file is ready, you can run the official Postee container image: aquasec/postee:latest, or compile it from source.</p> <p>There are different options to mount your customize configuration file to Postee - if running as a Docker container, then you simply mount the configuration files as a volume mount. If running as a Kubernetes deployment, you will need to mount it as a ConfigMap. See the below usage examples for how to run Postee on different scenarios.</p> <p>After Postee will run, it will expose two endpoints, HTTP and HTTPS. You can send your JSON messages to these endpoints, where they will be delivered to their target system based on the defined rules.</p>","title":"Installation"},{"location":"install/#docker","text":"<p>To run Postee as a Docker container, you mount the cfg.yaml to '/config/cfg.yaml' path in the Postee container.</p> <pre><code>docker run -d --name=postee -v /&lt;path to configuration file&gt;/cfg.yaml:/config/cfg.yaml \\\n    -e POSTEE_CFG=/config/cfg.yaml -e POSTEE_HTTP=0.0.0.0:8084 -e POSTEE_HTTPS=0.0.0.0:8444 \\\n    -p 8084:8084 -p 8444:8444 aquasec/postee:latest\n</code></pre>","title":"Docker"},{"location":"install/#kubernetes","text":"<p>When running Postee on Kubernetes, the configuration file is passed as a ConfigMap that is mounted to the Postee pod.</p>","title":"Kubernetes"},{"location":"install/#cloud-providers","text":"<pre><code>kubectl create -f https://raw.githubusercontent.com/aquasecurity/postee/main/deploy/kubernetes/postee.yaml\n</code></pre>","title":"Cloud Providers"},{"location":"install/#using-hostpath","text":"<pre><code>kubectl create -f https://raw.githubusercontent.com/aquasecurity/postee/main/deploy/kubernetes/hostPath/postee-pv.yaml\n</code></pre>  <p>Persistent Volumes Explained</p> <ul> <li><code>postee-db</code>: persistent storage directory <code>/server/database</code></li> <li><code>postee-config</code>: mount the cfg.yaml to a writable directory <code>/config/cfg.yaml</code></li> <li><code>postee-rego-templates</code>: mount custom rego templates</li> <li><code>postee-rego-filters</code>: mount custom rego filters</li> </ul>  <p>To edit the default Postee-UI user</p> <pre><code>kubectl -n postee set env deployment/my-posteeui -e POSTEE_ADMIN_USER=testabc -e POSTEE_ADMIN_PASSWORD=password\n</code></pre> <p>The Postee endpoints <pre><code>http://postee-svc.default.svc.cluster.local:8082\n</code></pre> <pre><code>https://postee-svc.default.svc.cluster.local:8445\n</code></pre></p> <p>The Postee-UI endpoint <pre><code>http://postee-ui-svc.default.svc.cluster.local:8000\n</code></pre></p>","title":"Using HostPath"},{"location":"install/#controllerrunner","text":"<p>To use Controller/Runner functionality within Kubernetes, you can follow a reference manifest implementation: - Controller - Runner</p>","title":"Controller/Runner"},{"location":"install/#helm","text":"<p>When running Postee on Kubernetes, the configuration file is passed as a ConfigMap that is mounted to the Postee pod.</p> <p>This chart bootstraps a Postee deployment on a Kubernetes cluster using the Helm package manager.</p>","title":"Helm"},{"location":"install/#prerequisites","text":"<ul> <li>Kubernetes 1.17+</li> <li>Helm 3+</li> </ul>","title":"Prerequisites"},{"location":"install/#test-the-chart-repository","text":"<pre><code>cd deploy/helm\nhelm install my-postee -n postee --dry-run --set-file applicationConfigPath=\"../../cfg.yaml\" ./postee\n</code></pre>","title":"Test the Chart Repository"},{"location":"install/#installing-the-chart-from-the-source-code","text":"<pre><code>cd deploy/helm\nhelm install app --create-namespace -n postee ./postee\n</code></pre>","title":"Installing the Chart from the Source Code"},{"location":"install/#installing-from-the-the-aqua-chart-repository","text":"<p>Let's add the Helm chart and deploy Postee executing:</p> <pre><code>helm repo add aquasecurity https://aquasecurity.github.io/helm-charts/\nhelm repo update\nhelm search repo postee\nhelm install app --create-namespace -n postee aquasecurity/postee\n</code></pre> <p>Check that all the pods are in Running state:</p> <p><code>kubectl get pods -n postee</code></p> <p>We check the logs:</p> <pre><code>kubectl logs deployment/my-posteeui -n postee | head\n</code></pre> <pre><code>kubectl logs statefulsets/my-postee -n postee | head\n</code></pre>","title":"Installing from the the Aqua Chart Repository"},{"location":"install/#delete-chart","text":"<pre><code>helm -n postee delete my-postee\n</code></pre>","title":"Delete Chart"},{"location":"install/#from-source","text":"<p>Clone and build the project: <pre><code>git clone git@github.com:aquasecurity/postee.git\nmake build\n</code></pre> After that, modify the cfg.yaml file and set the 'POSTEE_CFG' environment variable to point to it. <pre><code>export POSTEE_CFG=&lt;path to cfg.yaml&gt;\n./bin/postee\n</code></pre></p>","title":"From Source"},{"location":"routes/","text":"<p>A route is used to control message flows. Each route includes the input message condition, the template that should be used to format the message, and the action(s) that the message should be delivered to.</p> <p>The most important part of a route is the input definition using the Rego language to define what are the conditions for an incoming message to be handled by a certain route.</p> <p></p>  <p>Tip</p> <p>See the complete Rego Language in OPA-reference</p>  <p>After defining the route's input condition, what is left is to define the template that will be used to format the input message, and the action that formatted message will be sent to.</p> <p>The below table describes the fields to define a route:</p>    Key Description Possible Values Example     name Unique name of route string teams-vul-route   input A Rego rule to match against incoming messages. If there is a match then this route will be chosen for the incoming message Rego language statements contains(input.message,\"alpine\")   input-files One or more files with Rego rules Set of Rego language files [\"Policy-Registry.rego\", \"Policy-Min-Vulnerability.rego\"]   actions One or more actions that are defined in the \"actions\" section Set of action names. At least one element is required [\"my-slack\", \"my-email\"].   serialize-actions Serialize the list of actions true, false(default) true   template A template that is defined in the \"template\" section any template name raw-html    <p>The <code>rego-filters</code> folder contains examples of policy related functions. You can use the examples. To do this, you need to change the input data in the arrays of rego files and fill in the config file. If you want to use an other folder, set the 'REGO_FILTERS_PATH' environment variable to point to it. When using 2 or more files, they will be combined by \"OR\". To combine policy related functions by \"AND\", use the <code>Policy-Related-Features.rego</code> file, change the input data, and fill in the required function in allow. <pre><code>allow{\n    PermitImageNames\n    PermitMinVulnerability\n}\n</code></pre> If you are using your own rego files, then the package field should be \"postee\" and the result should be in the  allow function: <pre><code>package postee\n\nyour_function{...} # 0 or more your functions\n\nallow {\n    your_function\n}\n</code></pre> For example, the following input definition will match JSON messages that have 'image.name' field with value that contains the string 'alpine':</p> <pre><code>input: contains(input.image,\"alpine\")\n</code></pre> <p>Another example using regular expression: <pre><code>input: regex.match(\"alp:*\", input.image)\n</code></pre></p> <p>You can create more complex input definitions using the Rego language. For example, the following input definition will match JSON messages that have 'image.name' field with value 'alpine' and that their registry is 'Docker Hub' and they have a critical vulnerability.</p> <pre><code>input: |\n  contains(input.image,\"alpine\")\n  contains(input.registry, \"Docker Hub\")\n  input.vulnerability_summary.critical&gt;0\n</code></pre>","title":"Routes"},{"location":"routes/#postee-route-configuration","text":"<p>You could use Postee with any json. See the following example receiving json events:</p>","title":"Postee Route Configuration"},{"location":"routes/#route-all-messages","text":"<p>To create a route that matches all messages, simply use the following:</p> <pre><code>routes:\n- name: catch-all\n  input: input\n  ...\n</code></pre>","title":"Route All Messages"},{"location":"routes/#route-drift-prevention-messages","text":"<p>To create a route that matches only messages that originated from a \"Drift Prevention\" event, use the following:</p> <pre><code>routes:\n- name: catch-drift\n  input: contains(input.control, \"Drift\")\n  ...\n</code></pre>","title":"Route Drift Prevention Messages"},{"location":"routes/#route-tracee-message","text":"<p>The following input JSON message is from Tracee.</p> <p>Set <code>input</code> property of route to: <code>contains(input.SigMetadata.ID,\"TRC-\")</code> to limit the route to handle Tracee messages only</p> <p>In the section rego-templates have rego templates samples to use with Tracee: - tracee-html.rego - tracee-slack.rego</p>","title":"Route Tracee Message"},{"location":"routes/#plugins","text":"<p>'Plugins' section contains configuration for useful Postee features.</p>    Key Description Possible Values Example     aggregate-message-number Number of messages to aggregate into one message. any integer value 10   aggregate-message-timeout number of seconds, minutes, hours to aggregate Maximum is 24 hours Xs or Xm or Xh 1h   unique-message-props Optional. Comma separated list of properties which uniquely identifies an event message. If message with same property values is received more than once, consequitive messages will be ignored. Array of properties that their value uniquely identifies a message To avoid duplicate scanning messages you can use the following properties: <code>unique-message-props: [\"digest\",\"image\",\"registry\", \"vulnerability_summary.high\", \"vulnerability_summary.medium\", \"vulnerability_summary.low\"]</code>   unique-message-timeout Optional. Used along with unique-message-props, has no effect if unique props are not specified. Number of seconds/minutes/hours/days before expiring of a message. Expired messages are removed from db. If option is empty message is never deleted 1d","title":"Plugins"},{"location":"settings/","text":"<p>General settings are specified at the root level of cfg.yaml. They include general configuration that applies to the Postee application.</p> <p></p>    Key Description Possible Values Example Value     aqua-server Aqua Platform URL. This is used for some of the integrations to will include a link to the Aqua UI Aqua Platform valid URL https://server.my.aqua   db-verify-interval Specify time interval (in hours) for Postee to perform database cleanup jobs. Default: 1 hour any integer value 1   max-db-size The maximum size of Postee database (in B, KB, MB or GB). Once reached to size limit, Postee will delete old cached messages. If empty then Postee database will have unlimited size any integer value with a unit siffux 200kb, 1000 MB, 1Gb","title":"General"},{"location":"templates/","text":"<p>Templates are used to format input messages before sending them to the action. For example - before sending a message to Microsoft Teams there is a need to format the input JSON into an HTML. This is done using a template.</p> <p>Each template has a <code>name</code> field, which is used by the route to assign the template to input and output.</p>  <p>Tip</p> <p>Use the default Legacy template \"html\" for general output</p>  <p></p> <p>In addition to name, a template will have one of the 4 below keys:</p>    Key Description Example     rego-package Postee loads bundle of templates from <code>rego-templates</code> folder. This folder includes several templates shipped with Postee, which can be used out of the box. You can add additional custom templates by placing Rego file under the 'rego-templates' directory. <code>postee.vuls.html</code>   body Specify inline template. Relative small templates can be added to config directly input   url Load from url. Rego template can be loaded from url. http://myserver.com/rego.txt   legacy-scan-renderer Legacy templates are introduced to support Postee V1 renderers. Available values are  \"jira\", \"slack\", \"html\". \"jira\" should be used for jira integration, \"slack\" is for slack and \"html\" is for everything else. html     <p>Tip</p> <p>Pre made examples for templates can be found here</p>","title":"Templates"},{"location":"templates/#customizing-templates","text":"<p>It is possible to customize templates and even write new ones from scratch. Follow the guide in our advanced section here: Customizing Templates</p>","title":"Customizing Templates"},{"location":"templates/#troubleshooting-of-rego-templates","text":"<p>Rego templates provide very flexible way for transformation of received json. You can convert received information to html or json. On the flip side sometimes it may be difficult to find root cause of issue (if you run into any while configuring custom template). Postee application doesn't have many options to provide detailed error message. Very often if something goes wrong then 'result' property is omitted from rego evaluation result and it causes errors like: <pre><code>2021/07/23 18:27:31 Error while evaluating input: property result is not found\n</code></pre> So here are details to help with troubleshooting:</p>","title":"Troubleshooting of Rego Templates"},{"location":"templates/#required-tools","text":"<ul> <li>opa - tool to evaluate OPA queries directly</li> <li>jq - flexible command-line JSON processor.</li> </ul>","title":"Required tools"},{"location":"templates/#evaluate-template-to-build-html","text":"<p>Here is example of command to evaluate rego: <pre><code>opa eval data.postee.vuls.html.result --data vuls-html.rego --data common/common.rego --input &lt;path to input json&gt; | jq -r .result[0].expressions[0].value\n</code></pre> The example above should be started in <code>rego-templates</code> folder and evaluates default html template shipped with postee. First opa argument is query. Three parts are used to build query <code>data</code>.<code>&lt;your rego package&gt;</code>.<code>result</code>. You may want to evaluate title property. In this case query would be: <code>data</code>.<code>&lt;your rego package&gt;</code>.<code>title</code></p>","title":"Evaluate template to build html"},{"location":"templates/#evaluate-template-to-build-json","text":"<pre><code>cd rego-templates\nopa eval data.postee.vuls.slack.result --data vuls-slack.rego --data common/common.rego --input &lt;path to input json&gt; | jq .result[0].expressions[0].value\n</code></pre> <p>The command above is similar to html case but <code>jq</code> is used a bit different way.</p>","title":"Evaluate template to build json"},{"location":"ui/","text":"<p>Postee provides a simple Web UI to simplify the configuration management.</p> <p></p>","title":"Postee UI"},{"location":"ui/#configure-and-run-postee-ui-application","text":"","title":"Configure and run Postee UI application"},{"location":"ui/#requirements","text":"<p>Postee Admin application shares location of <code>cfg.yaml</code> with main webhook app, also Bolt database needs to be in folder which is available for both apps.</p>  <p>Danger<p>If application config is submitted by UI app then all yaml comments are removed. So if comments are important please make backup of config yaml.</p> </p>","title":"Requirements"},{"location":"ui/#kubernetes-for-postee-ui-application","text":"<p>The manifest is here.</p> <p>It will expose a service <code>postee-ui-svc</code> in the port <code>8000</code>.</p> <p><code>http://postee-ui.default.svc.cluster.local:8000</code></p>","title":"Kubernetes for Postee UI application"},{"location":"ui/#docker-image-for-postee-ui-application","text":"<p>Dockerfile to build image for UI app is here</p>","title":"Docker Image for Postee UI application"},{"location":"ui/#orchestration-example-docker-compose","text":"<p>There is an example of docker-compose.yml that can be used to simplify deploying of both app. Notice that two shared volumes are used. One is for Bolt db and second to store app config. To start apps use: <code>docker-compose up</code>.</p>","title":"Orchestration example (Docker Compose)"},{"location":"ui/#environment-variables","text":"Name Description Default value     POSTEE_UI_CFG Path to app config required, no default value   POSTEE_UI_PORT Port to use with UI app 8090   POSTEE_UI_UPDATE_URL Url of webhook application required   POSTEE_ADMIN_USER Admin account name admin   POSTEE_ADMIN_PASSWORD Admin account password admin","title":"Environment variables"},{"location":"actions/actions/","text":"","title":"Postee Actions"},{"location":"actions/actions/#motivation","text":"<p>Proper alert management can help security practitioners make informed decisions about their codebase. However, security alerts can cause fatigue if acting on them isn\u2019t possible. Postee, an open source security alert management tool, helps mitigate some of those concerns. It enables teams to define routes and rules by which alerts are handled and redirected to </p>","title":"Motivation"},{"location":"actions/actions/#user-stories","text":"<p>In a typical Postee setup, users can configure the tool to receive events from a variety of sources over a webhook. This allows for ease of use in existing environments. Furthermore, users can configure Postee to process these incoming events and, based on logic defined via Rego rules, send them to different actions.</p> <p>As a, Postee User - I want, to be able to remove a vulnerable image from my cluster upon a Trivy scan So that, I can keep such images unavailable for deployment.</p> <ul> <li> <p>I want, to ship Tracee security notification logs from my node when events are detected  So that, I can build a timelog for forensics purposes.</p> </li> <li> <p>I want, to be able to add labels to my deployments when Starboard detects a vulnerable image in my cluster  So that, I can effectively tag my resources.</p> </li> </ul>","title":"User Stories"},{"location":"actions/actions/#configuring-postee-actions","text":"<p>In this README, we\u2019ll walk through a scenario in which a user wants to act on a security event received from Tracee, an open source runtime security tool. In this scenario, the user will set up the Postee Exec Action to save logs for forensic purposes and then use the Postee HTTP Action to ship the saved logs to a remote server.</p> <p>In this case, the incoming security event from Tracee is received by Postee and evaluated by the following route YAML definition: </p> <p></p> <p>As seen above, the route has a Rego rule that evaluates the input to contain a certain signature ID, TRC-2, which represents anti-debugging activity. In addition, if the input is matched, the output is triggered.</p>","title":"Configuring Postee Actions"},{"location":"actions/actions/#exec-action","text":"<p>In this case, we call the Exec Action first and then the HTTP Action. They are defined as the following:</p> <p>The Exec Action can take in the following parameters:</p>    Option Usage     env Optional, custom environment variables to be exposed in the shell of the executing script   input-file Required, custom shell script to executed   exec-script Required, inline shell script executed    <p>The Exec Action also internally exposes the <code>$POSTEE_EVENT</code> environment variable with the input event that triggered the action. This can be helpful in situations where the event itself contains useful information.</p> <p>Below is an example of using <code>$POSTEE_EVENT</code>. It uses the inline exec-script script:</p> <p></p> <p>As you can see, we capture the incoming Postee event and write this event to the Tracee event log for forensic purposes.</p>","title":"Exec Action"},{"location":"actions/actions/#http-action","text":"<p>Finally, we can configure the Postee HTTP Post Action to ship the captured event logs via our HTTP Action to our remote server.</p> <p></p>    Option Usage     URL Required, URL of the remote server   Method Required, e.g., GET, POST   Headers Optional, custom headers to send   Timeout Optional, custom timeout for HTTP call   Bodyfile Optional, input file for HTTP post body    <p>To run Postee in the container, we can invoke the Postee Docker container:</p> <pre><code>docker run --rm --name=postee \\\n-v &lt;path-to-cfg&gt;:/config/cfg-actions.yaml  \\\n-e POSTEE_CFG=/config/cfg-actions.yaml \\\n-e POSTEE_HTTP=0.0.0.0:8084  \\\n-e POSTEE_HTTPS=0.0.0.0:8444  \\\n-p 8084:8084 -p 8444:8444 aquasecurity/postee:latest\n</code></pre>","title":"HTTP Action"},{"location":"actions/actions/#kubernetes-action","text":"<p>In addition to the Exec and HTTP actions, we have also implemented a Kubernetes action that today can add labels and annotations to pods. It can be used as follows:</p> <p></p>    Option Usage     kube-namespace Required. Kubernetes namespace to use.   kube-config-file Required. Path to .kubeconfig file   kube-label-selector Required, if specifying labels or annotations.   kube-actions Optional, key-value pair of labels and annotationsLabels must be added via \"labels\" key and Annotations via \"annotations\".","title":"Kubernetes Action"},{"location":"actions/actions/#docker-action","text":"<p>We have also added a Docker Action, that can help you run docker images as an action within a container.</p> <p></p>    Option Usage     docker-image-name Required. Image name of the docker image.   docker-cmd Required. Command to run inside the docker image.   docker-env Optional. Environment variables to set in the container.   docker-network Optional. Connect the action container to the specified network.   docker-volume-mounts Optional*. Volume mounts present inside the container. * If you have specified volume mounts, you also need to pass them through into the postee docker container","title":"Docker Action"},{"location":"actions/actions/#note","text":"<p>When running Postee in a Docker container, it is required to mount the Docker socket within the Postee container to be able to spin up Docker Action container instances. This can be done as follows: <pre><code>docker run --rm --name=postee --group-add $(stat -c '%g' /var/run/docker.sock) -v /var/run/docker.sock:/var/run/docker.sock -v /path/to/cfg.yaml:/config/cfg.yaml  -e POSTEE_CFG=/config/cfg.yaml -e POSTEE_HTTP=0.0.0.0:8084     -e POSTEE_HTTPS=0.0.0.0:8444     -p 8084:8084 -p 8444:8444 aquasecurity/postee:latest\n</code></pre></p> <p>If you have specified volume mounts for a docker container and use Postee in a docker container as well, remember to mount them within the Postee container as well: <pre><code>docker run --rm --name=postee --group-add $(stat -c '%g' /var/run/docker.sock) -v /var/run/docker.sock:/var/run/docker.sock -v /path/to/cfg.yaml:/config/cfg.yaml  -v /my/custom/volume:/my/custom/volume -e POSTEE_CFG=/config/cfg.yaml -e POSTEE_HTTP=0.0.0.0:8084     -e POSTEE_HTTPS=0.0.0.0:8444     -p 8084:8084 -p 8444:8444 aquasecurity/postee:latest\n</code></pre></p>","title":"Note"},{"location":"blueprints/external-healthcheck/","text":"","title":"Distributed Service Healthcheck"},{"location":"blueprints/external-healthcheck/#introduction","text":"<p>In this walkthrough, we will setup a globally distributed healthcheck for a service that we expect to be accessible from anywhere. This walkthrough will combine Postee Actions and AWS Lambda to accomplish this.</p>","title":"Introduction"},{"location":"blueprints/external-healthcheck/#scenario","text":"<p>A DevOps operator gets paged about a service that they maintain. This page turns out to be flaky and non-actionable. </p> <p>In order to avoid operator fatigue, we can confirm the correctness of the page by triggering several healthchecks upon the notification of such an event. These healthchecks are performed externally via Lambda functions spread across different regions. </p> <p>By performing such globally distributed checks, the operator can be rest assured of the accuracy of any failures and in addition narrow out the scope of the problem.</p> <p></p>","title":"Scenario"},{"location":"blueprints/external-healthcheck/#sample-configs","text":"<p>In this case a sample configuration for the components can be described as follows:</p>","title":"Sample Configs"},{"location":"blueprints/external-healthcheck/#postee-config","text":"<p>Postee Actions dispatches calls via the HTTP Action to 3 different AWS Lambda URLs. These requests are performed in parallel. In addition, the operator is performed of the trigger and notified via a Slack message.</p> <pre><code>routes:\n- name: actions-route\n  input: contains(input.ServiceURL.Reachable, \"false\")\n  actions: [send-slack-message, eu-check, apac-check, na-check]\n\n# Outputs are target services that should consume the messages\nactions:\n- name: send-slack-messsage\n  type: slack\n  enable: true\n  url: https://hooks.slack.com/services/TAAAA/BBB/&lt;key&gt;\n\n- name: eu-check\n  type: http\n  enable: true\n  url: \"https://&lt;uuid-func&gt;.lambda-url.&lt;aws-region&gt;.on.aws/\"\n  method: POST\n\n- name: apac-check\n  type: http\n  enable: true\n  url: \"https://&lt;uuid-func&gt;.lambda-url.&lt;aws-region&gt;.on.aws/\"\n  method: POST\n\n- name: na-check\n  type: http\n  enable: true\n  url: \"https://&lt;uuid-func&gt;.lambda-url.&lt;aws-region&gt;.on.aws/\"\n  method: POST\n</code></pre>","title":"Postee Config"},{"location":"blueprints/external-healthcheck/#lambda-config","text":"<pre><code>import os\nfrom datetime import datetime\nfrom urllib.request import Request, urlopen\n\nSITE = \"https://www.my-highly-available-website.com\"\nEXPECTED = \"Text I expect to find\"\n\ndef validate(res):\n    return EXPECTED in res\n\n\ndef lambda_handler(event, context):\n    timeNow = datetime.today().strftime('%Y-%m-%d-%H:%M:%S')\n    print('Checking {} at {}...'.format(SITE, timeNow))\n    try:\n        req = Request(SITE, headers={'User-Agent': 'AWS Lambda'})\n        if not validate(str(urlopen(req).read())):\n            raise Exception('Validation failed')\n    except:\n        print('Check failed!')\n        raise\n    else:\n        print('Check passed!')\n        return ('aquasec.com is up! at {}'.format(timeNow))\n    finally:\n        print('Check complete at {}'.format(str(datetime.now())))\n</code></pre> <p>Inspired by: https://github.com/amazon-archives/serverless-app-examples/blob/master/python/lambda-canary/lambda_function.py </p>","title":"Lambda Config"},{"location":"blueprints/image-processing/","text":"","title":"Doing Serverless Image Recognition using Postee Actions and AWS"},{"location":"blueprints/image-processing/#introduction","text":"<p>In this walkthrough, we will setup Postee Actions by re-using existing AWS Lambda Functions. This will allow anyone to configure and re-use existing AWS Lambda functionality as a Postee Action.</p>","title":"Introduction"},{"location":"blueprints/image-processing/#scenario","text":"<p>A user wants to be able to setup image processing of captured images in order to be able to identify any suspicious activity captured by the security (CCTV) camera.</p> <p>Upon successful identification, the user should be informed of such an event.</p> <p></p>","title":"Scenario"},{"location":"blueprints/image-processing/#sample-configs","text":"<p>In this case a sample configuration for the components can be described as follows:</p>","title":"Sample Configs"},{"location":"blueprints/image-processing/#postee-config","text":"<pre><code>routes:\n- name: actions-route\n  input: contains(input.Camera.Event, \"Finding\")\n  serialize-actions: true\n  actions: [send-slack-message, process-image]\n\n# Outputs are target services that should consume the messages\nactions:\n- name: send-slack-messsage\n  type: slack\n  enable: true \n  url: https://hooks.slack.com/services/TAAAA/BBB/&lt;key&gt;\n\n- name: process-image\n  type: http\n  enable: true\n  url: \"https://&lt;uuid-func&gt;.lambda-url.&lt;aws-region&gt;.on.aws/\"\n  method: POST\n</code></pre>","title":"Postee Config"},{"location":"blueprints/image-processing/#aws-rekognition-lambda-config","text":"<p>The full source code is omitted here for brevity but this example was inspired by: https://docs.aws.amazon.com/code-samples/latest/catalog/python-rekognition-rekognition_video_detection.py.html</p> <p>In order to setup the Lambda function we will need a handler that can process the incoming event from Postee. The below example demonstrates via Python psuedocode what this Lambda Handler could look like. <pre><code>import boto3\nfrom rekognition_objects import (\n    RekognitionFace, RekognitionVideo\n)\n\ndef do_face_detection(self):\n    return self._do_rekognition_job(\n        \"face detection\",\n        self.rekognition_client.start_face_detection,\n        self.rekognition_client.get_face_detection,\n        lambda response: [\n            RekognitionFace(face['Face'], face['Timestamp']) for face in\n            response['Faces']])\n\ndef lambda_handler(event, context):\n    rekognition_client = boto3.client('rekognition')\n    video = RekognitionVideo.from_event(event, rekognition_client)\n    faces = video.do_face_detection()\n    return faces\n</code></pre></p>","title":"AWS Rekognition &amp; Lambda Config"},{"location":"blueprints/trivy-vulnerability-scan/","text":"","title":"Trivy Vulnerability Scan"},{"location":"blueprints/trivy-vulnerability-scan/#introduction","text":"<p>In this walkthrough, we will setup vulnerability scanning with Trivy and send the results to Postee for creation of JIRA tickets as an example.</p> <p>A video format of this guide is also available here.</p>","title":"Introduction"},{"location":"blueprints/trivy-vulnerability-scan/#scenario","text":"<p>A DevOps team would like to configure alerts for scheduled vulnerability scans to be notify them about any vulnerable images that they might be running in their clusters. For this they decide to install Trivy, run it on a schedule and send the results to Postee.</p> <p>They decide to configure Postee so that upon receiving such alerts, Postee creates a JIRA ticket for them to take a look at it at their disposal.</p> <p></p>","title":"Scenario"},{"location":"blueprints/trivy-vulnerability-scan/#sample-configs","text":"<p>In this case a sample configuration for the components can be described as follows:</p>","title":"Sample Configs"},{"location":"blueprints/trivy-vulnerability-scan/#postee-config","text":"<p>Postee Actions dispatches calls via the HTTP Action to 3 different AWS Lambda URLs. These requests are performed in parallel. In addition, the operator is performed of the trigger and notified via a Slack message.</p> <pre><code>routes:\n- name: trivy-alpine-vulns\n  input: contains(input.Metadata.OS.Family, \"alpine\")\n  actions: [my-jira]\n  template: trivy-raw-json\n\n# Templates are used to format a message\ntemplates:\n- name: trivy-raw-json\n  rego-package: postee.rawmessage.json\n\n# Actions are target services that should consume the messages\nactions:\n- name: my-jira\n  type: jira\n  enable: true\n  url: \"https://foo.bar.com\"\n  user: \"jdoe@foo.bar.com\"\n  password: \"hunter2\"\n  project-key:   \"ABC\"\n  board:     \"Backlog\"\n  labels:    [\"trivy-vulns\"]\n</code></pre>","title":"Postee Config"},{"location":"blueprints/trivy-vulnerability-scan/#trivy-webhook-plugin-config","text":"<p>A simple bash script can be created in order to send results from Trivy to Postee. The script can then be loaded as a Trivy Plugin as documented here.</p> <pre><code>#!/bin/bash\n\n# Usage\nfunction usage() {\n  cat &lt;&lt; EOS &gt;&amp;2\nUsage: trivy webhook [-h,--help] TYPE NAME [TRIVY OPTION]\n A Trivy plugin that trivy reports to a webhook.\n\nOptions:\n  -h, --help    Show usage.\n\nExamples:\n  trivy webhook &lt;trivy args...&gt;\nEOS\n  exit\n}\n\nfunction scan {\n  trivy --quiet image --format=json $@\n}\n\nif [[ ($# -eq 0) || ($1 == \"--help\") || ($1 == \"-h\") ]]; then\n  # No commands or the --help flag passed and we'll show the usage instructions\n  usage\nfi\n\nwebhook_PARAM=()\nfor opt in \"$@\"; do\n  case \"${opt}\" in\n    '--' )\n      shift\n      TRIVY_PARAM=( \"$@\" )\n      break\n      ;;\n    * )\n      if [ -n \"$1\" ]; then\n        webhook_PARAM+=(\"$1\")\n      fi\n      shift\n      ;;\n  esac\ndone\n\nRESULTS=\"$(scan \"$@\")\"\necho $RESULTS\ncurl -s -H 'Content-Type: application/json' -d \"$RESULTS\" localhost:8082\n</code></pre>","title":"Trivy Webhook Plugin Config"}]}